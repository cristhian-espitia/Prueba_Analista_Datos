TRAEMOS LIBRERIAS A UTILIZAR:üë©‚Äçüíªüë©‚Äçüíª
import pandas as pd
import numpy as np
import os

TRAEMOS EL ARCHIVO , AJUSTANDOLO SEGUN EL SEPARADOR QUE TIENE ";"
df_persona= pd.read_csv('/content/drive/MyDrive/Persona2.csv', sep=';')
df_persona

CONOCIENDO LOS DATOS
¬øComo est√° perfilada las bases de datos ?

Visualizando todas las columnas

print (df_persona.columns)
print ('-----------------------------')

Descripcion
df_persona.describe()

Numero de filas y columnas
df_persona.shape

Tipo de datos
df_persona.dtypes 

Mayor y menor valor por columnas
max_values = df_persona.max()
min_values = df_persona.min()

print("Valor m√°ximo:")
print(max_values)

print("Valor m√≠nimo:")
print(min_values)

Longitud de campo
longitudes = df_persona.apply(lambda x: x.astype(str).str.len())
print(longitudes)

2. Programe y genere los indicadores de calidad de las siguientes reglas:
Reglas de calidad:
Verificamos si existen campos vacion en "NumldPersona"
campos_vacios_NumIdPersona = df_persona['NumIdPersona'].isna()
campos_vacios_NumIdPersona

Calculamos el n√∫mero de campos vac√≠os en la columna 'NumIdPersona' / cantidad de fallas en NumIdPersona
num_campos_vacios_NumIdPersona = campos_vacios_NumIdPersona.sum()
num_campos_vacios_NumIdPersona

if num_campos_vacios_NumIdPersona == 0:
    print("La regla 'El campo NumIdPersona no admite campos vac√≠os' se cumple.")
else:
    print("La regla 'El campo NumIdPersona no admite campos vac√≠os' no se cumple. Se encontraron", num_campos_vacios_NumIdPersona, "campos vac√≠os.")

 Indicador de calidad para la variable 'NumIdpersona'
total_registros_NumIdPersona = len(df_persona)
print("N√∫mero de campos llenos en 'NumIdPersona':", format(total_registros_NumIdPersona-num_campos_vacios_NumIdPersona,','))
porcentaje_campos_diligenciados= ((total_registros_NumIdPersona-num_campos_vacios_NumIdPersona)/total_registros_NumIdPersona)*100
print("Porcentaje de campos diligenciados en 'NumIdPersona':", round(porcentaje_campos_diligenciados,2), "%")  

En el campo ‚ÄúGenero‚Äù solo se admite como valido los valores ‚ÄúF‚Äù Y ‚ÄúM‚Äù
Verificamos si existen valores distintos de 'F' y 'M' en la columna 'Genero':
valores_invalidos_genero = df_persona.loc[~df_persona['Genero'].isin(['F', 'M']), 'Genero']
valores_invalidos_genero

Calculamos el n√∫mero de valores inv√°lidos en la columna 'Genero':
num_valores_invalidos_genero = len(valores_invalidos)
num_valores_invalidos_genero

if num_valores_invalidos == 0:
    print("En el campo ‚ÄúGenero‚Äù solo se admite como valido los valores ‚ÄúF‚Äù Y ‚ÄúM‚Äù ' se cumple.")
else:
    print("En el campo ‚ÄúGenero‚Äù solo se admite como valido los valores ‚ÄúF‚Äù Y ‚ÄúM‚Äù ' no cumple. Se encontraron", format(num_valores_invalidos,','), "campos invalidos.")

Indicador de calidad para la variable 'Genero
total_registros_genero = len(df_persona)
print("N√∫mero de campos validos en la columna 'Genero':", format(total_registros_genero-num_valores_invalidos_genero,','))
porcentaje_campos_validos_genero= ((total_registros_genero-num_valores_invalidos_genero)/total_registros_genero)*100
print("Porcentaje de campos validos en la columna 'Genero':", round(porcentaje_campos_validos_genero,2), "%")

En el campo ‚ÄúSegmento_poblacional‚Äù solo se permiten las siguientes opciones: Alto, B√°sico, Joven y Medio
Verificamos si existen valores distintos de las opciones permitidas en la columna 'Segmento_poblacional'
valores_invalidos_Segmento_poblacional = df_persona.loc[~df_persona['Segmento_poblacional'].isin(['Alto', 'B√°sico', 'Joven', 'Medio']), 'Segmento_poblacional']
valores_invalidos_Segmento_poblacional

Calcula el n√∫mero de valores inv√°lidos en la columna 'Segmento_poblacional':
num_valores_invalidos_Segmento_poblacional = len(valores_invalidos_Segmento_poblacional)
num_valores_invalidos_Segmento_poblacional


indicador_calidad_Segmento_poblacional = "Cumple" if num_valores_invalidos_Segmento_poblacional == 0 else "No cumple"
indicador_calidad_Segmento_poblacional

Generamos el indicador de calidad para la regla:
total_registros_segmento_poblacional = len(df_persona)
print("N√∫mero de campos validos en la columna 'Segmento poblacional':", format(total_registros_segmento_poblacional-num_valores_invalidos_Segmento_poblacional,','))
porcentaje_campos_validos_segmento_poblacional= ((total_registros_segmento_poblacional-num_valores_invalidos_Segmento_poblacional)/total_registros_segmento_poblacional)*100
print("Porcentaje de campos validos en la columna 'Segmento poblacional':", round(porcentaje_campos_validos_segmento_poblacional,2), "%")

Los errores generados para esta columna son en la palabra "B√°sico" y en la base datos compartida "Basico", sin tilde , esto genera que 251.425 datos se encuentren invalidos 

En el campo edad no se admite el valor 0 y tampoco puede tener m√°s de 2 caracteres
Verificamos si existen valores igual a 0 en la columna 'Edad'

valores_cero_edad = df_persona.loc[df_persona['Edad'] == 0, 'Edad']
valores_cero_edad

Calculamos el n√∫mero de valores igual a 0 en la columna 'Edad'
num_valores_cero_edad = len(valores_cero_edad)
num_valores_cero_edad

Verificamos si existen valores con m√°s de 2 caracteres en la columna 'Edad'
valores_largos_edad = df_persona.loc[df_persona['Edad'].astype(str).str.len() > 2, 'Edad']
valores_largos_edad

Calculamos el n√∫mero de valores con m√°s de 2 caracteres en la columna 'Edad'
num_valores_largos_edad = len(valores_largos_edad)
num_valores_largos_edad

indicador_calidad_edad = "Cumple" if num_valores_cero_edad == 0 and num_valores_largos_edad == 0 else "No cumple"
indicador_calidad_edad

print("Indicador de calidad para la regla 'En el campo Edad no se admite el valor 0 y tampoco puede tener m√°s de 2 caracteres':", indicador_calidad)

if num_valores_cero_edad > 0:
    print("Valores igual a 0 encontrados en la columna Edad:")
    print(num_valores_cero_edad)

if num_valores_largos_edad > 0:
    print("Valores con m√°s de 2 caracteres encontrados en la columna Edad:")
    print(num_valores_largos_edad)

Generamos el indicador de calidad para la regla:
 total_registros_edad = len(df_persona)
print("N√∫mero de campos validos en la columna 'edad':", format(total_registros_edad-(num_valores_cero_edad+num_valores_largos_edad),','))
porcentaje_campos_validos_edad= ((total_registros_edad-(num_valores_cero_edad+num_valores_largos_edad))/total_registros_edad)*100
print("Porcentaje de campos validos en la columna 'edad':", round(porcentaje_campos_validos_edad,2), "%")

Regla de negocio:
De acuerdo con el campo ‚ÄúCategoria‚Äù solo se permiten las siguientes opciones en el campo ‚ÄúSegmento_poblacional‚Äù

Este diccionario asocia cada categor√≠a con una lista de opciones permitidas para el campo 'Segmento_poblacional'.
De acuerdo con el campo ‚ÄúCategoria‚Äù solo se permiten las siguientes opciones en el campo ‚ÄúSegmento_poblacional‚Äù
opciones_permitidas_categoria = {
    'A': ['B√°sico', 'Joven', 'Medio'],
    'B': ['Joven', 'Medio'],
    'C': ['Alto', 'Joven', 'Medio']
}

combinaciones_invalidas_categoria = df_persona.loc[~df_persona.apply(lambda x: x['Segmento_poblacional'] in opciones_permitidas_categoria.get(x['Categoria'], []), axis=1)]
combinaciones_invalidas_categoria

Calculamos el n√∫mero de combinaciones no v√°lidas:
num_combinaciones_invalidas_categoria = len(combinaciones_invalidas_categoria)
num_combinaciones_invalidas_categoria

indicador_calidad_categoria = "Cumple" if num_combinaciones_invalidas_categoria == 0 else "No cumple"
indicador_calidad_categoria

print("Indicador de calidad para la regla 'De acuerdo con el campo Categoria solo se permiten las siguientes opciones en el campo Segmento_poblacional':", indicador_calidad_categoria)

if num_combinaciones_invalidas_categoria > 0:
    print("Combinaciones no v√°lidas encontradas:")
    print(combinaciones_invalidas_categoria[['Categoria', 'Segmento_poblacional']])

Imprimimos el indicador de calidad y las combinaciones no v√°lidas si corresponde:
 total_registros_categoria = len(df_persona)
print("N√∫mero de campos con conbinaciones validas:", format(total_registros_categoria-num_combinaciones_invalidas_categoria,','))
porcentaje_campos_validos_categoria= ((total_registros_categoria-num_combinaciones_invalidas_categoria)/total_registros_categoria)*100
print("Porcentaje de campos con combinaciones validas categoria y segmento_poblacional:", round(porcentaje_campos_validos_categoria,2), "%")   

